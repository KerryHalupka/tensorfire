<body>
<title>Cyborg Prose Environment</title>
<script src="../../dist/demo-util.js"></script>
<script src="../../dist/tensor.js"></script>
<script src="codemirror/codemirror.js"></script>
<link rel="stylesheet" href="codemirror/codemirror.css">


<style type="text/css">
    body {
        font-family: sans-serif;
        background: #005454;
        color: #eee;
        margin: 20px;
    }
    a {
        color: white;
    }
    .CodeMirror {
        font-family: sans-serif;
        border-radius: 5px;
    }

    .CodeMirror-lines {
        padding: 10px 0;
    }
    .CodeMirror pre {
        padding: 0 10px;
    }

    canvas {
        transform: scaleY(-1);
        z-index: -1;
        filter: blur(20px) hue-rotate(180deg);

        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        position: absolute;
    }
</style>

<h1>Cyborg Prose Environment</h1>
<p>This is a <b>experimental text editor</b>, with a neural creativity engine powering autocomplete. Just hit <b>Tab</b> and it'll invent a way to complete your sentence. Hit <b>Tab</b> multiple times to explore different completions.

<p>It's inspired by <a href="https://www.robinsloan.com/notes/writing-with-the-machine/">Robin Sloan's Atom plugin</a>, and powered by <b>TensorFire</b> and <b>CodeMirror</b>.</p>

<p>
    <select id="model_picker" value="trump-256" onchange="loadModel()"></select>

    Temperature: <input id="temperature" oninput="document.getElementById('temp').innerHTML = (+this.value).toFixed(2)" onchange="updateCompletion()" type="range" style="width: 300px" value="0.6" min="0.1" max="2" step="0.01"> <span id="temp">0.60</span> (higher temperatures yield weirder completions)
</p>

<canvas id="canvas"></canvas>

<script>

var models = {
    "shakespeare-128": {
        chars: ['\n', ' ', '!', '$', '&', "'", ',', '-', '.', '3', ':', ';', '?', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', ']', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],
        Ns: 128,
        Ni: 67,
        path: 'models/shakespeare-128'
    },
    "slatestar-256": {
        chars: ['\n', ' ', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~'],
        Ns: 256,
        Ni: 95,
        path: 'models/slatestar-256'
    }, 
    "trump-big.old": {
        chars: ['\n', '\r', ' ', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '=', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~'],
        Ns: 256,
        Ni: 94,
        path: 'models/trump-big.old'
    },
    "trump-256": {
        chars: ['\n', '\r', ' ', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '=', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~'],
        Ns: 256,
        Ni: 94,
        path: "models/trump-256"
    },
    "scifi-128": {
        chars: [' ', '!', '"', '#', "'", '(', ')', ',', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],
        Ni: 75,
        Ns: 128,
        path: 'models/scifi-128'
    }
}

for(let k in models){
    document.getElementById('model_picker').appendChild(new Option(k))
}



var gl = TF.createGL(document.getElementById('canvas')),
    OutputTensor = TF.OutputTensor,
    Tensor = TF.Tensor,
    InPlaceTensor = TF.InPlaceTensor;




const LSTM = `
    // Tensor output: [Ns, 1, 2]
    uniform Tensor X; // [Ni, 1, 1]
    uniform Tensor prev; // [Ns, 1, 2]
    uniform Tensor W; // [Ns, Ns + Ni + 1, 4]
    const int Ni = #(X.shape).x;
    const int Ns = #(W.shape).x;

    float tanh(float x){
        float e = exp(2.0 * clamp(x, -10.0, 10.0) );
        return (e-1.0)/(e+1.0);
    }
    float sigmoid(float x){ return 1.0/(1.0+exp(-clamp(x, -10.0, 10.0))); }
    float hard_sigmoid(float x){ return clamp(x * 0.2 + 0.5, 0.0, 1.0); }

    vec4 process4(ivec4 pos) {
        int j = pos.x;
        vec4 fioc = W.read4(j, 0); // bias
        for(int k = 0; k < Ni; k++) // inputs
            fioc += W.read4(j, 1 + k) * X.read4(k, 0).x; 
        for(int k = 0; k < Ns; k++) // prev outputs
            fioc += W.read4(j, 1 + Ni + k) * prev.read4(k, 0).x; 
        float c_t = hard_sigmoid(fioc.x) * prev.read4(j, 0).y 
                  + tanh(fioc.w) * hard_sigmoid(fioc.y); // state
        float h_t = tanh(c_t) * hard_sigmoid(fioc.z); // output
        return vec4(h_t, c_t, 0, 0);
    }
`


const TextureBuffer = `
    uniform Tensor buffer;
    uniform Tensor data;
    uniform int index;

    vec4 process4(ivec4 pos){
        if(pos.w == index){
            return data.read4(ivec4(pos.xyz, 0));
        }else{
            return buffer.read4(pos);
        }
    }
`

const FullyConnected = `
    uniform Tensor inputs;
    uniform Tensor W;
    uniform Tensor b;
    const int length = #(inputs.shape).x;

    vec4 process4(ivec4 pos) {
        vec4 sum = vec4(0, 0, 0, 0);
        for(int i = 0; i < length; i++){
            sum += inputs.read4(i, 0) * W.read4(i, pos.x);
        }
        return sum + b.read4(pos);
    }
`

const HardMax = `
    uniform Tensor data;
    const int length = #(data.shape).x;

    vec4 process4(ivec4 pos) {
        vec4 maxValue = vec4(-10000, -10000, -10000, -10000);
        for(int i = 0; i < length; i++){
            maxValue = max(maxValue, data.read4(i, 0));
        }
        return vec4(greaterThanEqual(data.read4(pos), maxValue));
    }
`

const WarmSample = `
    uniform Tensor data;
    uniform float temperature;
    uniform float random;

    const int length = #(data.shape).x;
    
    vec4 process4(ivec4 pos) {
        float sum = 0.0;
        for(int i = 0; i < length; i++){
            sum += exp(data.read4(i, 0).x / temperature);
        }
        float samp = 0.0;
        for(int i = 0; i < length; i++){
            float range = exp(data.read4(i, 0).x / temperature) / sum;
            if(random > samp && random < samp + range){
                return vec4(i, 0, 0, 0);
            }
            samp += range;
        }
        return vec4(0, 0, 0, 0);
    }
`

const OneHot = `
    uniform Tensor data;
    
    vec4 process4(ivec4 pos) {
        if(abs(float(pos.x) - data.read4(0, 0).x) < 1.0){
            return vec4(1, 1, 1, 1);
        }else{
            return vec4(0, 0, 0, 0);
        }
    }
`


async function loadArrayFromURL(fileName){
    var xhr = new XMLHttpRequest()
    xhr.open('GET', fileName, true)
    xhr.responseType = 'arraybuffer'
    xhr.send(null)
    await new Promise(resolve => xhr.onload = resolve)
    var buffer = new Float32Array(xhr.response)
    var shape = fileName.match(/\d+(x\d+)*$/)[0].split('x').map(k => +k)
    return ndarray(buffer, shape)
}


function destroyTensors(tensors){
    for(var i = 0; i < tensors.length; i++){
        if(tensors[i]){
            tensors[i].destroy()
        }
    }
}

var lstmWeights, denseWeights, denseBias, oneHotVector, charTensor, state, denseOutput, buffer;

async function loadModel(){
    
    var m = models[document.getElementById('model_picker').value],
        Ns = m.Ns, Ni = m.Ni;
    
    console.assert(Ni == m.chars.length);

    destroyTensors([ lstmWeights, denseWeights, denseBias, oneHotVector, charTensor, state, denseOutput, buffer ])


    lstmWeights = new Tensor(gl, await loadArrayFromURL(m.path + '/lstm_1_combined-'+Ns+'x' + (Ns+Ni+1) + 'x4'));
    denseWeights = new Tensor(gl, await loadArrayFromURL(m.path + '/dense_1-weights-kernel-'+Ns+'x'+Ni))
    denseBias = new Tensor(gl, await loadArrayFromURL(m.path + '/dense_1-weights-bias-'+Ni))


    oneHotVector = new OutputTensor(gl, [Ni, 1, 4])
    charTensor = new OutputTensor(gl, [1])
    state = new InPlaceTensor(gl, [Ns, 1, 4])
    denseOutput = new OutputTensor(gl, [Ni, 1, 4])
    buffer = new InPlaceTensor(gl, [ 1, 1, 1, 200 ])
    
}

loadModel()

function generateCompletion(input, temperature = 0.7){
    var m = models[document.getElementById('model_picker').value],
        Ns = m.Ns, Ni = m.Ni, chars = m.chars;

    var startTime = Date.now()
    for(let i = 0; i < buffer.shape[3]; i++){
        if(i < input.length)
            charTensor.update(ndpack([[ chars.indexOf(input[i]), 0, 0, 0 ]]));
        
        oneHotVector.run(OneHot, { data: charTensor })
        state.run(LSTM, { X: oneHotVector, prev: state, W: lstmWeights })
        denseOutput.run(FullyConnected, { inputs: state, b: denseBias, W: denseWeights })
        charTensor.run(WarmSample, { data: denseOutput, temperature: temperature, random: Math.random() })
        buffer.run(TextureBuffer, { buffer: buffer, data: charTensor, index: i })
    }

    buffer._show({ scale: 1 / Ni })
    var message = Array.from(buffer.read().data).map(k => chars[k]).join('').slice(input.length - 1)
    console.log('%c' + input + '%c' + message, 'color: black', 'color: blue');
    return message;
}



var cm = CodeMirror(document.body, {
    value: 'I AM GOING TO MAKE AMERICA',
    lineWrapping: true,
    extraKeys: {
        Tab: function(cm){
            updateCompletion()
        }
    }
});



const PREFIX = 'They expressed their feelings loud and clear. \n'

function updateCompletion(){
    var leadingText = (PREFIX + cm.getRange({ line: 0, ch: 0 }, cm.getCursor('from'))).slice(-50);
    var text = null;

    var raw_completion = generateCompletion(leadingText, +document.getElementById('temperature').value);
    try {
        text = raw_completion.match(/^.*?((\.|\!|\;)+\s|\n)/)[0]
    } catch (err) {
        text = raw_completion.split(' ').slice(0, 10).join(' ')
    }
    
    if(text){
        console.log('new text', text)
        cm.replaceSelection(text, 'around')    
    }else{
        console.warn('unable to find complete sentence', leadingText)
    }
}


</script>