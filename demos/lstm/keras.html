<body>
<script src="../../dist/demo-util.js"></script>
<script src="../../dist/tensor.js"></script>

<script>
var gl = KV.createGL(),
	OutputTensor = KV.OutputTensor,
	Tensor = KV.Tensor,
	InPlaceTensor = KV.InPlaceTensor,
	TP = s => (out, opt) => KV.Run(s.join(''), out, opt);


const LSTM = TP`
    // Tensor output: [Ns, 1, 2]
    uniform Tensor X; // [Ni, 1, 1]
    uniform Tensor prev; // [Ns, 1, 2]
    uniform Tensor W; // [Ns, Ns + Ni + 1, 4]
    const int Ni = #(X.shape).x;
    const int Ns = #(W.shape).x;

    float tanh(float x){
        float e = exp(2.0 * clamp(x, -10.0, 10.0) );
        return (e-1.0)/(e+1.0);
    }
    float sigmoid(float x){ return 1.0/(1.0+exp(-clamp(x, -10.0, 10.0))); }
    float hard_sigmoid(float x){ return clamp(x * 0.2 + 0.5, 0.0, 1.0); }

    vec4 process(ivec4 pos) {
        int j = pos.x;
        vec4 fioc = readTensor(W, j, 0); // bias
        for(int k = 0; k < Ni; k++) // inputs
            fioc += readTensor(W, j, 1 + k) * readTensor(X, k).x; 
        for(int k = 0; k < Ns; k++) // prev outputs
            fioc += readTensor(W, j, 1 + Ni + k) * readTensor(prev, k).x; 
        float c_t = hard_sigmoid(fioc.x) * readTensor(prev, j).y 
                  + tanh(fioc.w) * hard_sigmoid(fioc.y); // state
        float h_t = tanh(c_t) * hard_sigmoid(fioc.z); // output
        return vec4(h_t, c_t, 0, 0);
    }
`


var KerasWeights = {
  "W_xi": [[0.6283760666847229, -0.4726542532444, -0.6463563442230225, 0.442853718996048], [-0.09761910140514374, -0.524383008480072, -0.6479443311691284, -0.34025707840919495], [0.5125253200531006, -0.3751179575920105, 0.7326457500457764, -0.06373913586139679], [0.11021795123815536, 0.5261040925979614, 0.33278295397758484, -0.3074181079864502]],
  "W_hi": [[-1.0288935899734497, -0.07947301119565964, -0.24465300142765045, -0.29190218448638916], [-0.024111859500408173, 0.16644912958145142, 0.8523421287536621, -0.6747045516967773], [0.009573493152856827, -1.0703916549682617, 0.2484450340270996, 0.04944916069507599], [-0.3882072865962982, 0.17389804124832153, 0.6016085743904114, 0.8167751431465149]],
  "b_i": [0.10000000149011612, 0.30000001192092896, 0.20000000298023224, 0.6000000238418579],
  "W_xc": [[0.710383415222168, -0.2566174864768982, 0.5535924434661865, 0.5037380456924438], [-0.3718900680541992, -0.20778198540210724, 0.7432548999786377, 0.5881540775299072], [0.11676859110593796, -0.6871218085289001, 0.28988349437713623, 0.07020270824432373], [-0.3373783826828003, -0.21750414371490479, -0.28726908564567566, 0.34024137258529663]],
  "W_hc": [[0.49325841665267944, -0.14540766179561615, 0.9709505438804626, -0.052988942712545395], [-0.8729491233825684, 0.2861616313457489, 0.5045503973960876, 0.33391645550727844], [0.004233235958963633, 0.7823912501335144, 0.07301025837659836, -0.7697502970695496], [0.4523693323135376, 0.7034430503845215, -0.08575235307216644, 0.7093492746353149]],
  "b_c": [0.03999999910593033, 0.30000001192092896, 0.6000000238418579, 0.4000000059604645],
  "W_xf": [[-0.7182927131652832, 0.2043846994638443, -0.4945942163467407, 0.05371662601828575], [0.10009929537773132, -0.654586672782898, 0.5426405668258667, 0.27997341752052307], [0.09210319072008133, 0.23192478716373444, -0.5261338949203491, -0.586609959602356], [-0.7655434608459473, 0.6837518215179443, 0.41054224967956543, -0.6964260935783386]],
  "W_hf": [[-0.15152603387832642, -0.19551792740821838, -1.0713138580322266, -0.03315294161438942], [0.5102552175521851, -0.9420667290687561, 0.09259681403636932, 0.23146435618400574], [-0.09213040769100189, -0.2980825901031494, 0.09992773830890656, -1.0500824451446533], [0.9582230448722839, 0.4420744776725769, -0.20910952985286713, -0.22946010529994965]],
  "b_f": [0.6000000238418579, 0.07000000029802322, 1.0, 2.0],
  "W_xo": [[0.5941036939620972, 0.5932285189628601, -0.26900699734687805, -0.5175937414169312], [-0.8039950132369995, 0.8203487992286682, 0.4008657932281494, 0.4105130732059479], [-0.5878507494926453, -0.10162687301635742, -0.7703985571861267, -0.0026235063560307026], [0.06015267223119736, -0.2266588658094406, -0.5583896040916443, -0.037363454699516296]],
  "W_ho": [[-0.7254132628440857, -0.1930355727672577, 0.6273638606071472, 0.5029188990592957], [0.4370095431804657, 0.6025550961494446, 0.04234625771641731, 0.8087995648384094], [0.5247136950492859, 0.03054068423807621, 0.899379551410675, -0.35335418581962585], [0.4663407802581787, -0.8992952108383179, -0.07574812322854996, 0.4219675660133362]],
  "b_o": [1.0, 1.0, 1.0, 1.0]
};


const LSTMInput = ndpack([[0.1, 0.0, 0.9, 0.6], [0.5, 0.5, 0.5, 0.3]]);
const LSTMOutput = new Float64Array([0.15660709142684937, -0.12310830503702164, 0.3947620987892151, 0.4411243498325348]);

var Ns = 4,
    Ni = 4;
var W = zeros([Ns, Ns + Ni + 1, 4])
for(let i = 0; i < Ns; i++){
    // set the biases
    W.set(i, 0, 0, KerasWeights.b_f[i])
    W.set(i, 0, 1, KerasWeights.b_i[i])
    W.set(i, 0, 2, KerasWeights.b_o[i])
    W.set(i, 0, 3, KerasWeights.b_c[i])

    // forget gate weights
    ndops.assign(W.pick(i, null, 0).hi(1 + Ns).lo(1), 
        ndpack(KerasWeights.W_xf).pick(null, i))
    ndops.assign(W.pick(i, null, 0).lo(1 + Ns), 
        ndpack(KerasWeights.W_hf).pick(null, i))

    // input gate weights
    ndops.assign(W.pick(i, null, 1).hi(1 + Ns).lo(1), 
        ndpack(KerasWeights.W_xi).pick(null, i))
    ndops.assign(W.pick(i, null, 1).lo(1 + Ns), 
        ndpack(KerasWeights.W_hi).pick(null, i))

    // output gate weights
    ndops.assign(W.pick(i, null, 2).hi(1 + Ns).lo(1), 
        ndpack(KerasWeights.W_xo).pick(null, i))
    ndops.assign(W.pick(i, null, 2).lo(1 + Ns), 
        ndpack(KerasWeights.W_ho).pick(null, i))

    // state update weights
    ndops.assign(W.pick(i, null, 3).hi(1 + Ns).lo(1), 
        ndpack(KerasWeights.W_xc).pick(null, i))
    ndops.assign(W.pick(i, null, 3).lo(1 + Ns), 
        ndpack(KerasWeights.W_hc).pick(null, i))

}


var input1 = new Tensor(gl, LSTMInput.pick(0, null)),
	input2 = new Tensor(gl, LSTMInput.pick(1, null)),
	weights = new Tensor(gl, W),
	output = new InPlaceTensor(gl, [Ns, 1, 4]);

LSTM(output, { X: input1, W: weights, prev: output });
LSTM(output, { X: input2, W: weights, prev: output });

output.show()

console.log('Computed', ndshow(output.read().pick(null, 0, 0, 0)))
console.log('Reference', ndshow(ndarray(LSTMOutput)))
</script>